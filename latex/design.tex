\chapter{Design \& Process}\label{design-process}

\section{Process}\label{process}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Ideation \& Concept
\item
  Prototyping: esprima, atom, brackets, devtools?
\item
  User Testing, Probe (1 week)
\item
  Interview, evaluation in quantity and quality
\end{itemize}

\section{Existing solutions \& inspiration, similar solutions
(IDEATION)}\label{existing-solutions-inspiration-similar-solutions-ideation}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Syntax Highlighting (similar)
\item
  Indentation (similar)
\item
  Crockford’s context coloring (existing, inspiration)
\item
  Theseus’ grey colouring for code that hasn’t been called
\end{itemize}

\section{IDEATION}\label{ideation}

To support the ideation phase, the author created a collection of
existing UI components within IDEs. Those components were written down
on post-it notes.

The components were used a seeds for \emph{seeded brainstorming}: for
each of the components, the author tried to imagine solutions that are
similar, related to or based on the respective component.

Most of the ideas that came out of the brainstorming session made use of
multiple components, for example the \emph{context path} which is
described further down: it made use of a status bar as well as the code
editor.

Most of the ideas of the brainstorming phase made it into first
sketches. The sketching happened with two different approaches,
depending on if the code editor was involved or not.

For ideas that involved the code editor, it was important that the
author could work with real, functioning code. Therefore, two sample
JavaScript applications were created to work with:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  A small web server application, that would parse a markdown-formatted
  text file and render it into an HTML template. The application would
  run on Node.js and represents a typical control flow for e.g. a
  blogging engine (content + template = site).
\item
  A client-side script (runs in a browser) that fetches JSON data and
  presents them on a website, by the click of a button. This script
  represents typical client-side UI code, connecting a button event to a
  function and presenting the result in the UI.
\end{itemize}

Both applications were written in different styles: the server-side
application decouples the different tasks by putting them into different
functions (as far as it makes sense), whereas the client-side
application nests all function definitions inside each other, resulting
in nearly one function definition in each line, and deeper indentation
(ergo: higher code complexity).

A good solution for this design problem should address both cases.

Printouts of the two JavaScript files served as a basis for ideation
\emph{within source code}.

For concepts that would mainly work with other UI components, such as a
sidebar, or such concepts that would introduce new UI components, blank
paper was used for sketching.

\section{CONCEPTS}\label{concepts}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \emph{Context Path} - a path view of the context tree, similar to that
  of a selector path in an HTML editor (screenshot!). The context at the
  position of the cursor would be shown in a status bar. By hovering
  over a context level, the corresponding source code would be
  highlighted in the source editor.
\item
  \emph{Context Graph} - similar to a class browser, the context graph
  would represent a tree view of the application’s context(s). This
  could be implemented as a sidebar or panel.
\item
  \emph{Context Colouring} - similarly suggested by Crockford, the
  source code can be coloured in depending on its context (level).
  Crockfords variation is meant to replace syntax highlighting; one
  could, as well, complement syntax highlighting by colouring in the
  background (as e.g. Theseus does). 50 Shades of Grey.
\item
  \emph{Inspect Context} - comparable to DevTools’ \emph{Inspect
  Element} function, the user can right-click into the source code and
  choose \emph{Inspect Context}, which opens a panel that shows global
  variables, current local variables as well as the value of
  \texttt{this}.
\item
  \emph{Gutter Context} - any change of context or scope is indicated in
  the code editor’s gutter (similar to JSHint).
\item
  \emph{Quick Inspect} - similar to Brackets’ \emph{Quick Edit} feature,
  the value of \texttt{this} could be inspected inline.
\end{itemize}

\section{PROTOTYPING}\label{prototyping}

\section{USER TESTING, (Probe) (1
week)}\label{user-testing-probe-1-week}
